Разработчики LyCORIS очень подробно разобрали некоторые из алгоритмов в своём последнем пейпере: https://browse.arxiv.org/pdf/2309.14859.pdf

Более простая для чтения версия приведена ими же, вот здесь: https://github.com/KohakuBlueleaf/LyCORIS/blob/document/docs/Guidelines.md

✱ LoCon (LoRA for Convolution layer) - тренирует дополнительные слои в UNet. Теоретически должен давать лучший результат тренировки по сравнению с LoRA, меньше вероятность перетренировки и большая вариативность при генерации. Тренируется примерно в два раза медленнее чистой LoRA и понижает скорость в инференс тайме, размер выходного файла складывается из линейных слоёв + conv слоёв по той же формуле. Эти слои можно добавлять во время тренировки других алгоритмов.

✱ LoHa (LoRA with Hadamard Product representation) - тренировка с использованием алгоритма произведения Адамара. Способ максимизировать количество параметров в матрицах низкого ранга. Теоретически должен давать лучший результат при тренировках с датасетом в котором будет несколько концептов из-за лучшей генерализации, на деле может оказаться недостаточно хорошо передающим каждый из них в точности. Этот тип алгоритма имеет куда больший размер файла на низких рангах, не рекомендуется выставлять ранг выше ~32 или использовать большие альфы с ним.

✱ LoKr (LoRA with Kronecker product representation) - тренировка с использованием алгоритма произведения Кронекера. Ещё один способ вмешивания в матрицы, но в отличии от LoHa, делается это более произвольно. Контроллируется специальным параметром factor=X, где X - число контроллирующее количество параметров в матрице, чем он ниже, тем их будет больше, как и размер выходного файла. Работает это примерно как и с обычными лорами с низким рангом, в которых мало параметров, плохо воспроизводит тренируемые концепты с высоким значением factor, с низким похож на обычную лору, но более чувствителен к значению learning_rate, так же не рекомендуется использовать с большими альфа значениями. Пример применения - --network_dim=2048 --network_args "factor=4" даст примерно сопоставимый с обычной лорой нетворк.

✱ DyLoRA (Dynamic Search-Free LoRA) - по сути та же LoRA, только теперь в выходном файле размер ранга (network_dim) не фиксирован максимальным, а может принимать кратные промежуточные значения. После обучения на выходе будет один многоранговый файл модели, который можно разбить на отдельные одноранговые. Количество рангов указывается параметром --network_args "unit=x", т.е. допустим если network_dim=128, network_args "unit=32", то в выходном файле будут ранги 32,64,96,128. По заявлению разработчиков алгоритма, обучение одного многорангового файла в 4-7 раз быстрее, чем учить их по отдельности. В документации есть рекомендация по генерации и определения лучшего ранга такой натрененной лоры и последующего извелечения нужного ранга https://github.com/darkstorm2150/sd-scripts/blob/main/docs/train_network_README-en.md#dylora . Сама же генерация на разных рангах должна быть осуществима с помощью dyn=ранг_лоры с произвольным значением в хендлере лоры, пример - \<lora:loraname:unet=1:te=1:dyn=32\>.

✱ Full - при выборе этого алгоритма не происходит факторизации в низкий ранг, но всё ещё можно выбирать тренируемые части такого нетворка, можно это примерно сравнить с дримбутом, learning_rate тут нужен примерно такой же как и для него, размер выходнго файла как и потребление VRAM во время тренировки тут тоже больше.
